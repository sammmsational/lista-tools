import os
import sys
import shutil
import csv
import click
import requests
import pandas as pd
from prettytable import PrettyTable, DOUBLE_BORDER
from packaging import version as pv
from pathlib import Path

WORKING_DIR = os.getcwd()
VERSIONFILE_URL = r'https://raw.githubusercontent.com/stadtarchiv-lindau/lista-tools/master/VERSION'

if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
    # noinspection PyProtectedMember
    bundle_dir = Path(sys._MEIPASS)
    FILE_DIR = Path(sys.executable).parent
else:
    bundle_dir = Path(__file__).parent
    FILE_DIR = Path(__file__).parent


def get_element_type(path):
    """
    Used for table in batch_prefix()

    :param path: Path to element in filesystem
    :return: String of what the element is
    """
    if os.path.isfile(path):
        return "File"
    elif os.path.isdir(path):
        return "Folder"
    elif os.path.islink(path):
        return "Symlink"
    elif os.path.ismount(path):
        return "Mount point"
    else:
        return "Other"


def update():
    """
    Checks if newer version of the program exists
    :return: (installed_version: packaging.version.Version, installed_version_str: str); None if an error occurs
    """
    try:
        with open(bundle_dir / 'VERSION') as versionfile:
            installed_version_str = versionfile.read()
            installed_version = pv.parse(installed_version_str)
    except (FileNotFoundError, pv.InvalidVersion) as error:
        click.echo(f"[lista-tools]: An exception occurred when reading the local config file.")
        click.echo(f"{error}")
        installed_version = None
        installed_version_str = None

    # noinspection PyBroadException
    try:
        r = requests.get(VERSIONFILE_URL)
        available_version_str = r.content.decode().strip()  # decodes bytes object to str
        available_version = pv.parse(available_version_str)

    except Exception as E:  # KeyError if ConfigParser tries to read section of .ini that doesn't exist
        click.echo(f"[lista-tools]: An Error occurred when fetching the newest version. ")
        click.echo(f"{E}")
        available_version = None
        available_version_str = None

    if installed_version is None or available_version is None:
        return installed_version, installed_version_str, available_version, available_version_str

    if installed_version < available_version:
        click.echo(f"[lista-tools]: A newer version is available.")
        click.echo(f"[lista-tools]: Installed version: {installed_version_str}")
        click.echo(f"[lista-tools]: Version available: {available_version_str}")
        if click.confirm("[lista-tools]: Do you want to update?"):  # returns True if user confirms
            click.echo("[lista-tools]: Starting update. Please open lista-tools again after the update has finished.")
            # noinspection PyArgumentList
            os.startfile(bundle_dir / 'update.exe', arguments=str(str(FILE_DIR).encode().hex()))
            sys.exit()

    return installed_version, installed_version_str, available_version, available_version_str


@click.group()
def main():
    pass


@click.command()
def version():
    """
    Prints the currently installed version.
    """
    click.echo("------------------------------")
    if version_info is None:  # update() returns None if something went wrong
        click.echo(f"There was an error loading the local version file.")
    else:
        click.echo(f"Installed version: {version_info[1]}")
        click.echo(f"Newest version available: {version_info[3]}")
    click.echo("------------------------------")


@click.command()
@click.argument('input', type=click.Path(exists=True, dir_okay=False))
@click.option('-o', '--output', 'output', type=str, default='output.csv', help="The name of the output file. If not "
              "passed, file will be called 'output.csv'")
@click.option('-F', '--remove-folders', 'folders', is_flag=True, default=False, help="Removes all rows containing "
              "information on folders")
def droid_csv(input, output, folders):
    """
    Formats output csv from DROID to fit in LIStA Excel template.

    INPUT is the path to the input file. If no absolute path is given, the working directory will be used.
    """
    output_filename = os.path.basename(output)  # gets file name in case user passes a full output path

    with open(input, 'r', encoding='utf8') as f:
        click.echo(f"[lista-tools]: Opened input file")
        try:
            df = pd.read_csv(f)

        # had some problems in the past with files having more data columns than headers, which causes the parser to not
        # work. current fix is to manually add more header columns. this mostly happens with csv's containing data on
        # ~$xxx.doc lock files generated by Microsoft products, as DROID recognizes them to have multiple file formats
        except pd.errors.ParserError as pe:
            click.echo(f"[lista-tools]: An error occurred: {pe}")
            click.echo(f"[lista-tools]: This is most likely due to some rows having not enough header columns. "
                       f"Try editing the csv file accordingly.")
            sys.exit()
        click.echo(f"[lista-tools]: Loaded data to DataFrame")

    if folders:  # removes rows that contain folders
        df = df[df["TYPE"].str.contains("Folder") == False]
        click.echo(f"[lista-tools]: Removed rows with folders")
        click.echo(f"[lista-tools]: Corrected index")

    df.index += 1
    df = df.astype({'SIZE': 'Int64', 'ID': 'Int64', 'PARENT_ID': 'Int64', 'FORMAT_COUNT': 'Int64'})  # removes decimals
    click.echo(f"[lista-tools]: Formatted numbers as integers")
    df = df.drop(['URI', 'FILE_PATH', 'METHOD', 'STATUS'], axis=1)  # removes columns not present in template
    click.echo(f"[lista-tools]: Dropped unused columns")

    if os.path.exists(output):
        click.confirm(f"[lista-tools]: The file '{output_filename}' already exists. "
                      "Do you want to overwrite?", abort=True)

    click.echo("\n")
    click.echo(df.head())  # prints preview of output
    click.echo("\n")

    with open(output, 'w', encoding='utf8') as f:
        # csv.QUOTE_ALL to prevent issues with whitespace characters in data
        # header=False removes header row, since the Excel template has its own header row
        df.to_csv(f, quoting=csv.QUOTE_ALL, lineterminator='\n', header=False)
        click.echo(f"[lista-tools]: Saved successfully as '{output_filename}'")


@click.command()
@click.option('-R', '--no-recursion', 'no_recursion', is_flag=True, default=False, help="Will only extract folders "
              "once")
def exdir(no_recursion):
    """
    Extracts all folders inside the working directory and adds the folder name as a prefix to its contents
    Will repeat this process until there are only files in the working directory, can be disabled with the '-R' flag
    """
    def extract():
        for directory in os.listdir(WORKING_DIR):
            # skips to next element if current one is a file
            # if extract() is called by itself all files are already gone from the directory
            if os.path.isfile(directory):
                continue
            path_to_directory = os.path.join(WORKING_DIR, directory)  # path to directory in WORKING_DIR

            for element in os.listdir(directory):  # loops all elements inside first-level directory
                path_to_element = os.path.join(path_to_directory, element)
                new_name = f"{directory.upper()}_ {element}"  # adds prefix to name
                new_path = os.path.join(path_to_directory, new_name)  # new_path is just the old path with new filename
                os.rename(path_to_element, new_path)
                shutil.move(new_path, WORKING_DIR)
                click.echo(f"[lista-tools]: Moved: ./{directory}/{element} -> ./{new_name}")

            os.rmdir(path_to_directory)  # removes dir once it's empty

        if no_recursion:
            return

        # calls itself again if there are still more directories to extract
        for element in os.listdir(WORKING_DIR):
            if os.path.isdir(element):
                click.echo(f"[lista-tools]: Extracting directory: ./{element}")
                extract()
                break

    # calls function for the first time
    extract()


@click.command()
@click.argument('source_dir', required=False, type=click.Path(exists=True, file_okay=False))
@click.option('-S', '--no-space', 'no_space', is_flag=True, default=False, help="Does not add a space after the prefix")
def rename(source_dir, no_space):
    """
    Renames all files and directories in SOURCE_DIR by adding a prefix to them.

    If SOURCE_DIR is not passed, the working directory will be used.
    """
    change_prefix = True
    prefix = None
    if source_dir is None:
        source_dir = WORKING_DIR

    while True:
        if change_prefix:
            prefix = click.prompt("[lista-tools]: Please enter a prefix to add")
            change_prefix = False

        table = PrettyTable(["ID", "Old filename", "New filename", "Type"])  # table to show before vs after
        for idx, element in enumerate(os.listdir(source_dir), 1):  # uses idx as ID; starts at 1
            path_to_element = os.path.join(source_dir, element)
            if no_space:
                new_name = f"{prefix}{element}"
            else:
                new_name = f"{prefix} {element}"

            element_type = get_element_type(path_to_element)
            table.add_row([idx, element, new_name, element_type])

        table.align = "l"
        table.align["ID"] = "r"
        table.set_style(DOUBLE_BORDER)
        click.echo(table)

        click.echo(f"[lista-tools]: Do you want to apply the changes?")
        user_choice = click.prompt("[Y] Yes, apply   [N] No, change the prefix   [S] Toggle --no-space  "
                                   "[C] Cancel").casefold()[0]
        match user_choice:
            case "y":
                break
            case "n":
                change_prefix = True
                continue
            case "s":
                no_space = not no_space
                continue
            case _:
                click.echo(f"[lista-tools]: Aborting")
                sys.exit()

    for element in os.listdir(source_dir):
        path_to_element = os.path.join(source_dir, element)
        if no_space:
            new_name = f"{prefix}{element}"
        else:
            new_name = f"{prefix} {element}"

        new_path = os.path.join(source_dir, new_name)
        os.rename(path_to_element, new_path)
        click.echo(f"[lista-tools]: Renamed: {element} -> {new_name}")


main.add_command(droid_csv)
main.add_command(exdir)
main.add_command(version)
main.add_command(rename)


if __name__ == '__main__':
    version_info = update()  # checks for updates before running
    main()
